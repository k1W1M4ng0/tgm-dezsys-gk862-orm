# SYT Dezentrale Systeme GK862 Spring Data & ORM

## Questions

## Spring Data with MySQL

I created this project with the Spring Initializr with the dependencies: 
Spring Web, Spring Data JPA, and MySQL Driver.

### MySQL database

For the database, I used a docker container: 

```bash
# start the container
docker run \
    --name mysql \
    -e MYSQL_ROOT_PASSWORD=password \
    -p 3306:3306 \
    -d mysql

# create a database

docker exec -it mysql mysql --password
# enter 'password'

```

```sql
create database db_example;
create user 'springuser'@'%' identified by 'password';
grant all on db_example.* to 'springuser'@'%'; -- Gives all privileges to the new user on the newly created database
```

### application.properties

For the db connection, I wrote into the file `src/main/resources/application.properties`:

```
spring.application.name=spring-orm

spring.jpa.hibernate.ddl-auto=update
spring.datasource.url=jdbc:mysql://${MYSQL_HOST:localhost}:3306/db_example
spring.datasource.username=springuser
spring.datasource.password=password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.show-sql: true
```

### User.java

For this exercise, I will save User.java objects into the database.

The class has to be annotated with `@Entity`, and the ID with 
`@ID` and `@GeneratedValue(strategy = GenerationType.AUTO)`

### UserRepository.java

```java
public interface UserRepository extends CrudRepository<User, Integer> {
    // this will be auto implemented
}
```

### Controller

```java
@Controller
public class MainController {
    // autowire the generated userRepository bean to this
    @Autowired
    private UserRepository userRepository;

    // i want to also use GET requests, for simplicity
    @RequestMapping("/add")
    public @ResponseBody String addNewUser(
            @RequestParam String name,
            @RequestParam String email) {


        // create a new user
        User n = new User();
        n.setName(name);
        n.setEmail(email);

        // save the user to the db
        userRepository.save(n);

        return "Saved";
    }

    @RequestMapping("/all")
    public @ResponseBody Iterable<User> getAllUsers() {
        // get all users
        return userRepository.findAll();
    }
}
```

### Testing

test this with [adding a user](http://localhost:8080/add?name=Simon&email=sgao)
and [getting all users](http://localhost:8080/all)

## WarehouseData with MySQL

For saving WarehouseData (+ Product) objects, they have to be turned into entity models.

First, I changed the id to be an Integer instead of a String. I then set the strategy to AUTO.

I changed the timestamp in Warehouse to a LocalDateTime, for some later tasks.

The most important bit is the relation between the classes:

```java
// in WarehouseData
    @OneToMany(mappedBy = "warehouse", fetch = FetchType.LAZY, cascade = CascadeType.MERGE)
	private List<Product> productData;


// in Product
    @ManyToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumn(name = "warehouseID")
    private WarehouseData warehouse;
```

One WarehouseData saves multiple Products, so this side gets a @OneToMany annotation.

mappedBy is the name of the attribute in Product, which maps back to the warehouse.

Multiple products can belong to a warehouse, so i put a @ManyToOne annotation there.

@JoinColumn is the name of the column in the database

### Testing

for testing, i first manually added data to the tables

```sql
USE DATABASE db_example;

-- clear tables
DELETE FROM product;
INSERT INTO product VALUES
    (1, 'Electronics', 'Smartphone', 100, 'Piece'),
    (2, 'Electronics', 'Laptop', 50, 'Piece'),
    (3, 'Books', 'Novel', 200, 'Piece'),
    (4, 'Books', 'Textbook', 150, 'Piece'),
    (5, 'Stationery', 'Pencil', 500, 'Box'),
    (6, 'Stationery', 'Notebook', 300, 'Piece'),
    (7, 'Clothing', 'T-Shirt', 250, 'Piece'),
    (8, 'Clothing', 'Jeans', 100, 'Piece'),
    (9, 'Groceries', 'Bread', 1000, 'Loaf'),
    (10, 'Groceries', 'Milk', 500, 'Gallon');
-- products generated by ai since i was lazy coming up with examples

DELETE FROM warehouse_data;
INSERT INTO warehouse_data VALUES
    (1, '2023-11-15 10:00:00', '123 Main St', 'APP123', 'New York', 'USA', 'Warehouse A', '10001'),
    (2, '2023-11-15 11:00:00', '456 Market St', 'APP456', 'Los Angeles', 'USA', 'Warehouse B', '90001');
-- again generated by ai


select * from product;
select * from warehouse_data;
DELETE FROM warehouse_data;
DELETE FROM product;
```

I also added an api to add a predefined set of product + warehousedata.

```java
// in MainController
    @Autowired
    private ProductRepository pRepo;

    @RequestMapping("/add/warehouseProduct")
    public @ResponseBody String addWarehouseProduct() {
        Product p = new Product();
        p.setProductID(1);
        p.setProductName("name2");
        p.setProductUnit("unit3");
        p.setProductQuantity(4);
        p.setProductCategory("cat5");

        WarehouseData d = new WarehouseData();

        p.setWarehouse(d);
        d.setProductData(List.of(p));

        // saving in whrepo is not necessary thanks to cascade type all in Product
        // whRepo.save(d);

        pRepo.save(p);

        return "saved";
    }
```

## Sources

- [Spring Boot "Accessing Data with MySQL" tutorial](https://spring.io/guides/gs/accessing-data-mysql)

